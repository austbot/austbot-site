---
title: "Ruby Crypto: Stateless use of rbnacl..."
date: "2018-02-16T14:01:02.000Z"
description: "https://unsplash.com/photos/8yYAaguVDgYI’m not a Rubyist, I’m more..."
image: 
link: https://ygrene.tech/ruby-crypto-stateless-use-of-rbnacl-6e0f3cb2b1eb?source&#x3D;rss-993e52e8750e------2
---
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*CXNQW2ZhXOKhjBHMqxPT0A.jpeg" /><figcaption><a href="https://unsplash.com/photos/8yYAaguVDgY">https://unsplash.com/photos/8yYAaguVDgY</a></figcaption></figure><p>I’m not a Rubyist, I’m more into JavaScript, Haskell and Scala. But, to help my team at work, I have been diving deep into Ruby. I’m starting to enjoy it. This post is meant to help those not so familiar with the language get a handle on <a href="https://github.com/crypto-rb/rbnacl">rbnacl</a> and how to use binary strings. Within the precious contents, I unpack a project, the problems I encountered, and how I solved them.</p><h3>The Design</h3><p>I needed to make a secure upload system and my first choice was Ruby of course since it’s where my team is the strongest. My design for the secure file upload system is roughly the following:</p><ol><li>A service calls the upload service to get a link. The call is made with a few bits of info, s3 bucket and path, link expiry, metadata, and a challenge array. The challenge array is used to verify the user getting the upload link is who they say they are without being authenticated. This could be a password, email, last 4 of social, etc…</li><li>The information is serialized into a string then encrypted.</li><li>The encrypted string is packed into a url safe base64 encoded string.</li><li>When the user uses the link, the token is consumed by the service and the information is decrypted. The expiry is checked then the service uses the metadata and the challenge to produce a json schema or form that it sends back to the user.</li><li>The user will solve the challenge and the information along with the token are sent back. The token is decrypted once again and the challenge is safely checked.</li><li>If the challenge is successfully answered, then the service uses the information about the upload stored in the decrypted token to construct an S3 upload policy.</li><li>The policy is then signed using AWS v4 signature SDK. The policy is sent back to the user and the Frontend uses it to construct a form.</li><li>When the user adds documents to the page, the upload will go straight to S3 using the signed request.</li><li>The s3 bucket has events turned on and a virus scanning service goes to work making sure the documents are clean.</li><li>From there the rest is very boring.</li></ol><h3>What you’ll need</h3><p>At first glance of the above design, I would reach for AWS lambda, and a dynamo db table, but that wouldn’t be any fun for the rest of my team. So I put the following restraints on myself.</p><ol><li>No Database</li><li>Ruby Only</li></ol><p>With those constraints in place, let’s look at the ingredients list.</p><ol><li><strong>Framework: </strong>You’ll need Rails, Sinatra or whatever the cool kids are using these days.</li><li><strong>Crypto</strong>: You will also need a way to encrypt things. rbnacl is what I chose. It used the sodium native library behind the scenes.</li><li><strong>Cloud: </strong>Aws SDK for me thank you.</li><li><strong>Coffee: </strong>Light roast, organic and always direct trade.</li></ol><p>Since the framework and AWS are well documented let’s move to the Crypto part. After my exhaustive research I decided that the builtin Crypto library was ‘unhip’ and that rbnacl was the way to go. Especially when I saw this in their docs.</p><blockquote>NaCl puts cryptography on Rails! Instead of making you choose which cryptographic primitives to use, NaCl provides convention over configuration in the form of expertly-assembled high-level cryptographic APIs that ensure not only the confidentiality of your data, but also detect tampering. These high-level, easy-to-use APIs are designed to be hard to attack by default in ways primitives exposed by libraries like OpenSSL are not. — <a href="https://github.com/crypto-rb/rbnacl">rbnacl docs</a></blockquote><p>I’m not a complete idiot when it comes to security and cryptography, but I’m not an expert either. So using a library that takes the collective brain power of lots of security people and lets me focus on what I want to do with my service, sounds great! So I cracked my knuckles and installed rbnacl and rbnacl-libsodium (installs sodium for you and tweaks rbnacl for you to look on the gem path for it by monkey patching stuff like all good Ruby libraries should).</p><p><strong>First Tip: Gemfile order</strong></p><p>Rails loads your gems from top to bottom. So make sure if you are wanting rbnacl-libsodium to install sodium for you that it is the first gem in your Gemfile to also have rbnacl as a dependency. This is really important if you use the jwt gem, since it requires rbnacl too.</p><p><strong>Second Tip: How to Store your Private Key</strong></p><p>If you are like me, you wanted to use rbnacl to generate a private key. And if you are like me you want to actually be able to encrypt/decrypt stuff with it. In order to do this, you will need to store the key somewhere. I chose to have each environment of my service have a specific private key. At first I had trouble storing it.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c3446577300c4a24304910c6f2e7be6d/href">https://medium.com/media/c3446577300c4a24304910c6f2e7be6d/href</a></iframe><p>I started reading through the docs, not the rbnacl docs, but the Ruby docs on string encoding and eventually landed on this nice little solution.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1244620817116523f4d96e125696c7b9/href">https://medium.com/media/1244620817116523f4d96e125696c7b9/href</a></iframe><p><strong>Third Tip: Using Nonces without a db</strong></p><p>So I had my key and I’m encrypting things right an left, but I ran into a snag. Using the secure box method you need to create a nonce before you encrypt stuff. This nonce is a one time use thing. It is meant to ensure perfect forward secrecy. In this case, that means any time you generate a link, even if it’s the exact same payload being encrypted, the resulting encrypted token will be different. This also means you have to keep track of the silly little nonce. Typically I would do this with a redis, mongo, dynamo db, cockroach db, rethink db, raven db, your mom db, why are there so many databases db, or heck even a mysql if we are gonna get crazy. Wait, I can’t use a database! This application needs to be stateless. Why? Because I feel like it okay. And it lends itself to super simple deployments and coordination. So here is what I did. Using my private key from tip 2, and a nonce. I wrote some encryption helpers that will do the following. I have removed a few things that don’t matter, but in essence, and with a better design pattern, the below is what is happening.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/72cb0953bb176eb65f371a3cb2e73f10/href">https://medium.com/media/72cb0953bb176eb65f371a3cb2e73f10/href</a></iframe><p>Well, that’s all folks. I hope its helpful</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6e0f3cb2b1eb" width="1" height="1"><hr><p><a href="https://ygrene.tech/ruby-crypto-stateless-use-of-rbnacl-6e0f3cb2b1eb">Ruby Crypto: Stateless use of rbnacl</a> was originally published in <a href="https://ygrene.tech">Ygrene Tech</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>